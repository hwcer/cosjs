/**
 * config:session配置
 * config.lock 用户进程锁, 默认:false(关闭),格式:[num,ms,reload],
 * config.lock = [10,500,1]
 * 仅当在session存放用户cache时才有必要将reload设置为 true
 *
 */
"use strict";
var redis   = require('./lib/redis');
var crypto  = require('./lib/crypto');


var config = {
    key:"_id",                                 //session id key
    type:"cookie",                            //session id 存储方式,get,post,cookie
    level  : 1,                                //安全点等级，0:不验证,1:基本验证,2:基本验证+进程锁
    redis  : null,                             //redis连接
    secret : Date.now().toString(),            //加密字符串
    prefix : "session",                       //session hash 前缀
    expire : 86400,                             //有效期,S
    lockNum : 5,
    lockTime : 200,
    ObjectID : true,                              //使用ObjectID作为session ID,false:必须指定UID
    formatter : null,                             //session 数据序列化
}

var reqDataName = {'get':'query','post':'body','path':'params','cookie':'cookies'};

module.exports = function(opts){
    var mergeOpts = Object.assign({},config,opts);
    return function(req,res,next){
        req.session = new session(req,res,mergeOpts);
        next();
    }
}

//全局配置
exports.configure = function(opts){
    config = Object.assign(config,opts);
}


var session = function ( req, res , option ) {
    var self = this;
    this.sid      = '';
    this.uid      = '';
    this.cosjs    = true;      //仅仅是一个标记
    this.delay    = 0;
    this.redis    = null;
    this.level    = 0;
    this.locked   = 0;
    this.closed   = 0;          //是否已经终止(前端非正常结束)
    this.userData = null;

    this._locked_key  = '_locked_key';
    this._expire_time = '_expire_time';

    Object.defineProperty(this,'option',{
        value: option,
        writable: false,
        enumerable: false,
        configurable: false,
    });

    res.on('close', function(){  session_unlock.call(self); });
    res.on('finish',function(){  session_unlock.call(self); });
    //启动session
    this.start = function(callback,path){
        if(this.redis){
            return callback(null,this.userData);
        }
        this.level = session_level.call(this,req,res,path);
        session_start.call(this,req,res,callback);
    }
    //创建session,登录时使用:uid,data,callback
    this.create = function(){
        if(option.ObjectID){
            var uid = null,data=arguments[0],callback=arguments[1];
        }
        else {
            var uid = arguments[0],data=arguments[1],callback=arguments[2];
        }
        session_create.call(this,req,res,uid,data,callback);
    }
};



//获取一个或者多个在session中缓存的信息
session.prototype.get = function (key) {
    if(!this.userData){
        return null;
    }
    return this.userData[key]||null;
};
//写入数据，不会修改session,可用于临时缓存
session.prototype.set = function (key,val,callback) {
    if(!this.uid){
        return callback('logout','session uid empty');
    }
    this.redis.set(this.uid,key,val,callback);
};
//删除一个或者多个在session中缓存的信息，keys==null,删除所有信息，退出登录
session.prototype.del = function(key,callback){
    this.redis.del(this.uid,key,callback);
};


function session_start(req,res,callback){
    this.redis = new redis(this.option.redis);
    this.redis.prefix = this.option.prefix;
    this.redis.formatter = this.option.formatter;
    if(!this.level){
        return callback(null,this.userData);
    }
    this.sid = get_session_id.call(this,req);
    if( !this.sid ){
        return callback('logout','session id[' + this.option.key + '] empty');
    }
    if(this.option.ObjectID){
        this.uid = this.sid;
    }
    else{
        this.uid = crypto.decode(this.sid,this.option.secret);
    }
    if( !this.uid ){
        return callback('logout','sid error');
    }
    var self = this;
    get_session_data.call(self,function(err,ret){
        if (err) {
            return callback(err, ret);
        }
        var ret_SVal = ret[self.option.key]||'';
        var ret_LVal = parseInt(ret[self._locked_key]||0);
        if ( !ret_SVal || self.sid != ret_SVal) {
            return callback("logout", "session id illegal");
        }
        if( self.level <2 ){
            session_result.call(self,callback);
        }
        else if (ret_LVal > 0) {
            session_delay.call(self,callback);
        }
        else{
            session_lock.call(self,callback);
        }
    });
};

function get_session_id(req){
    var key = reqDataName[this.option.type];
    if(!key || !req[key]){
        return false;
    }
    return req[key][this.option.key] || null;
}


function get_session_data(callback){
    var self = this;
    this.redis.get(self.uid, null, function (err, ret) {
        if (err) {
            return callback(err, ret);
        }
        else if (!ret) {
            return callback('logout', 'session not exist');
        }
        else{
            self.userData = ret;
            return callback(err, ret);
        }
    });
}


function session_lock(callback){
    var self = this;
    if(self.closed){
        return session_aborted.call(self,callback);
    }
    self.redis.incr(self.uid, self._locked_key, 1, function (err, ret) {
        if (err) {
            callback(err, ret);
        }
        else if (ret > 1) {
            session_delay.call(self,callback);
        }
        else {
            self.locked = 1;
            session_result.call(self,callback);
        }
    });
};

function session_delay(callback){
    var self = this;
    if(self.closed){
        return session_aborted.call(self,callback);
    }
    if( self.delay >= self.option.lockNum ){
        return callback("locked",self.delay);
    }
    self.delay ++;
    setTimeout(function(){
        session_lock.call(self,callback);
    },self.option.lockTime);
};

function session_result(callback){
    var self = this;
    if(self.closed){
        return session_aborted.call(self,callback);
    }
    if(self.locked > 0 && self.delay >0){
        get_redis_data.call(self,function(err,ret) {
            if (err) {
                return callback(err, ret);
            }
            callback(null,self.userData);
        })
    }
    else{
        callback(null,self.userData);
        if(this.option['expire']){
            session_reset.call(self);
        }
    }
};

function session_reset(){
    var self = this;
    var key = self._expire_time;
    var nowTime = Date.now();
    var difTime = ( nowTime - self.userData[key] ) / 1000;
    if(difTime < (self.option.expire /2) ){
        return ;
    }
    this.redis.set(self.uid,key,nowTime,session_callback);
    this.redis.expire(self.uid,self.option.expire,session_callback);
}

function session_level(req,res,path){
    var level;
    var typeoflevel = typeof this.option.level;
    if(typeoflevel === 'function'){
        level = this.option.level(req,res);
    }
    else if(typeoflevel === 'object'){
        path = path || req.baseUrl;
        level = path in this.option.level ? this.option.level[path] : (this.option.level['default'] || 0);
    }
    else {
        level = this.option.level;
    }
    return level;
}

function session_create(req,res,uid,data,callback) {
    var self = this;
    if(this.option.ObjectID){
        var sid = crypto.ObjectID();
        this.uid = sid;
    }
    else{
        var sid = crypto.encode(uid,self.option.secret);
        this.uid = uid;
    }
    this.sid = sid;
    var newData = Object.assign({},data);
    newData['uid'] = uid;
    newData[self.option.key] = sid;
    newData[self._locked_key] = 0;
    newData[self._expire_time] = Date.now();

    self.redis.set(self.uid,newData,function(err,ret){
        if(err){
            return callback(err,ret);
        }
        if(self.option.expire){
            self.redis.expire(self.uid,self.option.expire);
        }
        if(self.option.type == 'cookie'){
            res.cookie(self.option.key, sid, {})
        }
        return callback(null,sid);
    });
}

function session_unlock(){
    this.closed = 1;
    if( !this.locked ){
        return false;
    }
    this.locked = 0;
    if(!this.uid){
        return false;
    }
    this.redis.set(this.uid,this._locked_key,0,session_callback);
};

function session_aborted(callback){
    if(this.locked && this.uid){
        this.locked = 0;
        this.redis.set(this.uid,this._locked_key,0,session_callback);
    }
    return callback("aborted");
}

function session_callback(err,ret){
    return err?false:ret;
}