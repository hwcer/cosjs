/**
 * config:session配置
 * config.lock 用户进程锁, 默认:false(关闭),格式:[num,ms,reload],
 * config.lock = [10,500,1]
 * 仅当在session存放用户cache时才有必要将reload设置为 true
 *
 */
"use strict";

const library    = require('cosjs.library');
const redis     = library('redis/hash');
const format    = library('format');

const SESSION_KEY    = '_sid';
const SESSION_LOCK   = '_lock';

exports = module.exports = function(opts){
    var config = require('./config');
    var mergeOpts = Object.assign({},config,opts);
    if( mergeOpts.method && !Array.isArray(mergeOpts.method)){
        mergeOpts.method = [mergeOpts.method];
    }
    return function(req,res,next){
        Object.defineProperty(req, 'session', {  value: new session(req,res,mergeOpts),  writable: false, enumerable: true, configurable: false, });
        next();
    }
}


function session(req,res,option) {
    var self = this;
    this.sid      = '';    //session id
    this.uid      = '';    // user id
    this.data     = null;
    this.redis    = null;
    this.level    = option.level || 1;
    this._delay    = 0;
    this._locked   = 0;
    this._closed   = 0;          //是否已经终止(前端非正常结束)

    Object.defineProperty(this,'option',{
        value: option,
        writable: false,
        enumerable: false,
        configurable: false,
    });

    Object.defineProperty(this,'crypto',{
        value: library('crypto')(option.secret,6),
        writable: false,
        enumerable: false,
        configurable: false,
    });

    //启动session
    this.start = function(callback){
        if(this.redis){
            throw new Error('session start again');
        }
        if(this.level >=2) {
            res.on('close',  function () { session_unlock.call(self); });
            res.on('finish', function () { session_unlock.call(self); });
        }
        session_start.call(this,req,res,callback);
    }
    //创建session,登录时使用:uid,data,callback
    this.create = function(){
        if(option.guid){
            var uid = null,data=arguments[0],callback=arguments[1];
        }
        else if(arguments.length >=3){
            var uid = arguments[0],data=arguments[1],callback=arguments[2];
        }
        else{
            throw new Error('session create arguments length error');
        }
        session_create.call(this,req,res,uid,data,callback);
    }
};

//获取一个或者多个在session中缓存的信息
session.prototype.get = function (key,type) {
    if(!this.data || !(key in this.data) ){
        return null;
    }
    var val = this.data[key];
    if(type){
        val = format(val.type);
    }
    return val;
};
//写入数据，不会修改session,可用于临时缓存
session.prototype.set = function (key,val,callback) {
    if(!this.uid){
        return callback('logout','session uid empty');
    }
    this.redis.set(this.uid,key,val,callback);
};
//删除一个或者多个在session中缓存的信息，keys==null,删除所有信息，退出登录
session.prototype.del = function(key,callback){
    this.redis.del(this.uid,key,callback);
};

function session_start(req,res,callback){
    this.redis = new redis(this.option.redis,this.option.prefix,this.option.format);
    if(this.level < 1){
        return callback(null,null);
    }
    this.sid = get_session_id.call(this,req,res);
    if( !this.sid ){
        return callback('logout','session id[' + this.option.key + '] empty');
    }

    if(this.option.guid){
        this.uid = this.sid;
    }
    else{
        this.uid = this.crypto.decode(this.sid);
    }
    if( !this.uid ){
        return callback('logout','sid error');
    }
    var self = this;
    get_session_data.call(self,function(err,ret){
        if (err) {
            return callback(err, ret);
        }
        var ret_sid = ret[SESSION_KEY]||'';
        var ret_lock = parseInt(ret[SESSION_LOCK]||0);
        if ( !ret_sid || self.sid != ret_sid) {
            return callback("logout", "session id illegal");
        }
        if( self.level < 2 ){
            session_result.call(self,callback);
        }
        else if (ret_lock > 0) {
            session_delay.call(self,callback);
        }
        else{
            session_lock.call(self,callback);
        }
    });
};

function get_session_id(req,res){
    var val=null,skey = this.option.key;
    var reqDataName = {'cookie':'cookies','get':'query','post':'body','path':'params'};
    var keys = this.option.method ? this.option.method : Object.keys(reqDataName);
    for(let k of keys){
        if(!reqDataName[k]){
            throw new Error('session option[method] value "'+k+'" is not a valid value');
        }
        var name = reqDataName[k];
        if(req[name] && (skey in req[name])){
            val = req[name][skey];
            break;
        }
    }
    return val;
}


function get_session_data(callback){
    var self = this;
    this.redis.get(self.uid, null, function (err, ret) {
        if (err) {
            return callback(err, ret);
        }
        else if (!ret) {
            return callback('logout', 'session not exist');
        }
        else{
            self.data = ret;
            return callback(err, ret);
        }
    });
}


function session_lock(callback){
    var self = this;
    if(self._closed){
        return session_aborted.call(self,callback);
    }
    self.redis.incr(self.uid, SESSION_LOCK, 1, function (err, ret) {
        if (err) {
            callback(err, ret);
        }
        else if (ret > 1) {
            session_delay.call(self,callback);
        }
        else {
            self._locked = 1;
            session_result.call(self,callback);
        }
    });
};

function session_delay(callback){
    var self = this;
    if(self._closed){
        return session_aborted.call(self,callback);
    }
    if( self._delay >= self.option.lockNum ){
        return callback("locked",self._delay);
    }
    self._delay ++;
    setTimeout(function(){
        session_lock.call(self,callback);
    },self.option.lockTime);
};

function session_result(callback){
    var self = this;
    if(self._closed){
        return session_aborted.call(self,callback);
    }
    if( self.level >=3 && self._locked > 0 && self._delay >0){
        get_redis_data.call(self,function(err,ret) {
            if (err) {
                return callback(err, ret);
            }
            callback(null,self.data);
        })
    }
    else{
        callback(null,self.data);
    }
};



function session_create(req,res,uid,data,callback) {
    var self = this,sid;
    if(this.option.guid){
        this.uid = sid = this.crypto.ObjectID();
    }
    else{
        this.uid = uid;
        sid = this.crypto.encode(uid);
    }
    this.sid = sid;
    var newData = Object.assign({},data);
    newData[SESSION_KEY]  = sid;
    newData[SESSION_LOCK] = 0;
    self.redis.multi();
    self.redis.set(self.uid,newData,null);
    if(self.option.expire){
        self.redis.expire(self.uid,self.option.expire);
    }
    self.redis.save(function(err,ret){
        if(err){
            return callback(err,ret);
        }
        if( !self.option.method || self.option.method.indexOf('cookie') >=0 ){
            res.cookie(self.option.key, sid, {});
        }
        self._locked = 0;
        return callback(null,sid);
    });
}

function session_unlock(){
    this._closed = 1;
    if( !this._locked ){
        return false;
    }
    this._locked = 0;
    if(!this.uid){
        return false;
    }
    session_reset.call(this);
};

function session_aborted(callback){
    if(this._locked && this.uid){
        this._locked = 0;
        session_reset.call(this);
    }
    return callback("aborted");
}

function session_reset(){
    this.redis.multi();
    this.redis.set(this.uid,SESSION_LOCK,0);
    this.redis.expire(this.uid,this.option.expire);
    this.redis.save(function(err,ret){
        //console.log('session_reset',err,ret);
    });
}


function session_callback(err,ret){
    return err?false:ret;
}