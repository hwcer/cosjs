"use strict";
const cosjs_socket  = require('../library/socket');
const cosjs_manager = require('../library/manager');

exports = module.exports = function(opts){
    if(!this.manager){
        throw new Error('cosjs.socket start gateway but manager opts empty ');
    }
    var root = [this.root, 'gateway'].join('/');
    var application = cosjs_socket(root,opts);
    //连接MASTER
    var manager = cosjs_manager(this.manager);
    application.defineHandlePrototype('manager',manager);

    application.queue = new Set();
    application.waitTime = [];    //平均等待时间
    application.connector = new Map();
    application.connectorset = new Set();
    application.vigourSet  = new Set();
    application.vigourLet = application.vigourSet.entries();
    //监控connector list变化
    manager.on('connector',function(opts){
        //console.log('connector',JSON.stringify(opts));
        var key = opts.key;
        if(!application.connector.has(key) ){
            application.connector.set(key,opts);
        }
        if( opts['online'] < opts['maxClient'] ){
            application.vigourSet.add(key);   //人数减少重新进入列队
        }
        else{
            application.vigourSet.delete(key);
        }
    });

    application.on('connection', function (socket){
        socket.STime = Date.now();
        application.queue.add(socket.id);
        var size = application.queue.size;
        socket.emit('queue',{index:size,total:size,wait:averageWaitTime.call(application)} );
        socket.on('disconnect', function (){
            application.queue.delete(socket.id);
        });
    });

    queueBegin.call(application);
    return application;
};


function queueBegin(){
    var self = this;
    setTimeout( function(){ queue.call(self);},1000);
}


function queue(){
    if( this.vigourSet.size == 0 ){
        return queueBegin.call(this);
    }
    if(this.queue.size==0 ){
        return queueBegin.call(this);
    }

    var sub = 0;
    for(let sid of this.queue){
        this.queue.delete(sid);
        if( !distribute.call(this,sid) ){
            break;
        };
        sub ++;
    }
    if(sub > 0) {
        var queue = {total: this.queue.size, wait: averageWaitTime.call(this),'sub':sub};
        this.emit('queue', queue);
    }
    queueBegin.call(this);
}


function distribute(sid){
    var socket = this.sockets.sockets[sid];
    if(!socket){
        return true;
    }
    var key = connectorEntries.call(this);
    if(!key){
        return false;
    }
    var connector = this.connector.get(key);
    socket.emit('host',{host:connector.host,port:connector.port});
    var ETime = Date.now();
    var WTime = ETime - socket.STime;
    this.waitTime.push(WTime);
    if(this.waitTime.length > 100){
        this.waitTime.shift();
    }
    socket.disconnect(true);
    connector.online ++;
    if(connector['online'] >= connector['maxClient']){
        this.vigourSet.delete(key);
    }
    return true;
}

function connectorEntries(){
    if(this.vigourSet.size == 0){
        return false;
    }
    var entries = this.vigourLet.next();
    if( entries.done){
        this.vigourLet = this.vigourSet.entries();
        return connectorEntries.call(this);
    }
    return entries.value[0];
}


function averageWaitTime(){
    if(this.waitTime.length==0){
        return 0;
    }
    var sum = this.waitTime.reduce(function(previousValue, currentValue, index, array){
        return previousValue + currentValue;
    });
    return Math.ceil(sum / this.waitTime.length);
}