"use strict";
const library  = require('cosjs.library');

exports = module.exports = function(opts,emitter){
    var port = opts.port;
    var application  = require('socket.io')(opts.port,opts);
    application.emitter = library("emitter")(Object.assign({},emitter,{pattern:false}));

    application.slice      = opts['slice'] || 100;
    application.queue      = new Set();
    application.waitTime   = [];                 //平均等待时间
    application.connector  = new Map();
    application.vigourSet  = new Set();
    application.vigourLet  = application.vigourSet.entries();
    application.vigourVal  = null;
    //监控connector list变化
    application.emitter.on('connector',function(opts){
        var key = opts['key'];
        opts['zone'] = 0;
        if(!application.connector.has(key) ){
            application.connector.set(key,opts);
        }
        if( opts['online'] < opts['maxClient'] ){
            application.vigourSet.add(key);      //人数减少重新进入列队
        }
        else{
            application.vigourSet.delete(key);
        }
    });

    application.on('connection', function (socket){
        socket.STime = Date.now();
        application.queue.add(socket.id);
        var size = application.queue.size;
        socket.emit('queue',{index:size,total:size,wait:averageWaitTime.call(application)} );
        socket.on('disconnect', function (){
            application.queue.delete(socket.id);
        });
    });
    queueBegin.call(application);
    return application;
};


function queueBegin(){
    var self = this;
    setTimeout( function(){ queue.call(self);},1000);
}


function queue(){
    if( this.vigourSet.size == 0 ){
        return queueBegin.call(this);
    }
    if(this.queue.size==0 ){
        return queueBegin.call(this);
    }

    var sub = 0;
    for(let sid of this.queue){
        if( !distribute.call(this,sid) ){
            break;
        };
        sub ++;
    }
    if(sub > 0) {
        var queue = {total: this.queue.size, wait: averageWaitTime.call(this),'sub':sub};
        this.emit('refresh', queue);
    }
    queueBegin.call(this);
}


function distribute(sid){
    var socket = this.sockets.sockets[sid];
    if(!socket){
        return true;
    }
    var connector = connectorEntries.call(this);
    if(!connector){
        return false;
    }
    socket.emit('gateway',{host:connector.host,port:connector.port});
    var ETime = Date.now();
    var WTime = ETime - socket.STime;
    this.waitTime.push(WTime);
    if(this.waitTime.length > 100){
        this.waitTime.shift();
    }
    socket.disconnect(true);
    connector.online ++;
    this.queue.delete(sid);
    return true;
}

function connectorEntries(){
    if(this.vigourSet.size == 0){
        return false;
    }
    if(!this.vigourVal){
        var entries = this.vigourLet.next();
        if( entries.done){
            this.vigourLet = this.vigourSet.entries();
            return connectorEntries.call(this);
        }
        this.vigourVal = entries.value[0];
    }

    var connector = this.connector.get(this.vigourVal);

    if( !connector || connector['online'] >= connector['maxClient']){
        this.vigourVal = null;
        this.vigourSet.delete(this.vigourVal);
        return connectorEntries.call(this);
    }

    if(connector['zone'] >= this.slice){
        this.vigourVal = null;
        return connectorEntries.call(this);
    }
    connector['zone'] ++;
    return connector;
}


function averageWaitTime(){
    if(this.waitTime.length==0){
        return 0;
    }
    var sum = this.waitTime.reduce(function(previousValue, currentValue, index, array){
        return previousValue + currentValue;
    });
    return Math.ceil(sum / this.waitTime.length);
}