"use strict"
const pool = require('./pool');
const mongodb = require('mongodb');

exports = module.exports = class mongodb_Collection {
    constructor(Mongodb,CollName) {
        this.callback     = mongodb_callback;
        this.ErrorReCall = 10;                              //数据库写入失败后反复尝试的次数
        this.ErrorReTime = 100;                             //数据库写入失败后下次重新写入时间

        this._Mongodb    = Mongodb;
        this._CollName   = CollName;
        this._MongoColl  = null;
        this._MultiColl  = null;


    }

    collection(callback){
        var self = this;
        callback = callback || mongodb_callback;
        if(this._MongoColl){
            return callback(null,this._MongoColl);
        }
        mongodb_client(this._Mongodb,function(err,db){
            if(err){
                return callback(err,db);
            }
            self._MongoColl = db.collection(self._CollName);
            callback(null,self._MongoColl);
        });
    }

    exec(callback,ErrorReNum){
        if(!this._MultiColl){
            return callback(null, 'mongodb multi empty');
        }
        var options = {};
        callback = callback || mongodb_callback;
        if(this._MultiColl._MultiCache.length < 1){
            return callback(null,'mongodb multi operations empty');
        }

        var self = this;
        ErrorReNum = ErrorReNum || 0;
        ErrorReNum++;

        var result = function(err,ret){
            if(!err){
                self._MultiColl = null;
                return callback(null,ret);
            }
            else if( ErrorReNum >= self.ErrorReCall ){
                var update = self._MultiColl._MultiCache;
                self._MultiColl = null;
                return mongodb_ErrorLogs('exec',null,update,options,err,callback);
            }
            else{
                setTimeout(function(){
                    self.exec(callback,ErrorReNum);
                },ErrorReNum * self.ErrorReTime)
            }
        }

        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            coll.bulkWrite(self._MultiColl._MultiCache,options,result);
        });
    }

    save(callback){
        this.exec(callback);
    }
    multi(){
        if(!this._MultiColl){
            this._MultiColl = new MultiColl(this);
        }
        return this._MultiColl;
    }
    //id,keys,[option],callback
    get(id,keys) {
        var next=2,option={},callback;
        if(typeof arguments[next] == 'object'){
            option = arguments[next];
            next ++;
        }
        if(typeof arguments[next] == 'function'){
            callback = arguments[next];
            next ++;
        }
        var query  = this.query(id);
        var fields = this.fields(keys);
        if(!('multi' in option)) {
            option['multi'] = this.isMultiWrite(id);
        }
        var json = ['json','object'];
        if( json.indexOf(option['dataType']) >=0 && keys!==null ){
            fields['_id'] = 1;
        }
        option['fields'] = fields;
        var result = mongodb_findResult.bind(this,option,callback);
        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            if(option["multi"]){
                coll.find(query, option, result);
            }
            else{
                coll.findOne(query, option, callback);
            }
        });
    }
//id,key,[val,callback]
    set(id,key) {
        var val,next = 2,callback;
        if(typeof arguments[next] !== 'function'){
            val = arguments[next];
            next++;
        }
        callback = (typeof arguments[next] === 'function') ? arguments[next] : mongodb_callback;

        var query = this.query(id);
        var update = {"$set":this.values(key,val)};
        var option = {"upsert": false,"multi":this.isMultiWrite(id)};
        this.update(query,update,option,callback);
    }
    //删除
    del(id,callback) {
        callback = callback || mongodb_callback;
        var query  = this.query(id);
        var option = {"multi":this.isMultiWrite(id)};
        this.remove(query,option,callback);
    }
    incr(id, key,val) {
        var next = 3,fields,callback;
        if(Array.isArray(arguments[next])){
            fields = arguments[next];
            next++;
        }
        callback = (typeof arguments[next] === 'function') ? arguments[next] : mongodb_callback;

        var query  = this.query(id);
        var update = {"$inc":this.values(key,val)};
        var option = {"upsert": false,"multi":this.isMultiWrite(id)};
        if(fields){
            if(fields.indexOf(key)<0){
                fields.push(key)
            }
            option['fields'] = this.fields(fields);
        }
        this.update(query,update,option,callback);
    }

    unset(id,key,callback) {
        callback = callback || mongodb_callback;
        var query  = this.query(id);
        var update = {"$unset":this.values(key,1)};
        var option = {"multi":this.isMultiWrite(id)};
        this.update(query,update,option,callback||mongodb_callback);
    }

    //分页显示
    page(query, page, size, sort, option, callback){
        size = size || 10;
        if(page<1){
            page = 1;
        }
        option['multi'] = true;
        option['sort'] = sort;
        option['fields'] = option['fields'] || {};
        var data = {"page":page,"size":size,"total":0,"records":option['records']||0,"rows":[] };
        var cursor , skip  = (page - 1 ) * size ,limit = size ;

        var result = function (err,ret) {
            data['total'] = Math.ceil(data['records'] / data['size']);
            data['rows'] = Array.isArray(ret)?ret:[];
            callback(null,data);
        }

        var getCount = function(err,ret){
            if(err){
                return callback(err,ret);
            }
            data['records'] = ret;
            setPage();
        }

        var setPage = function(){
            cursor.skip(skip).limit(limit).toArray(result);
        }

        var getCursorCallback = function(err,ret){
            if(err){
                return callback(err,ret);
            }
            cursor = ret;
            if(!data['records']){
                cursor.count(getCount);
            }
            else {
                setPage();
            }
        }

        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            coll.find(query, option, getCursorCallback);
        });
    }
    //删除
    remove(query,option,callback,ErrorReNum) {
        callback = callback || mongodb_callback;
        if(this._MultiColl){
            return this._MultiColl.delete(query,option,callback);
        }
        var self = this;
        ErrorReNum = ErrorReNum || 0;
        ErrorReNum++;

        var result = function(err,ret){
            if(!err){
                return callback(null,ret['result']);
            }
            else if( ErrorReNum>=self.ErrorReCall || err['code'] == 11000 ){
                return mongodb_ErrorLogs('remove',query,'',option,err,callback);
            }
            else{
                setTimeout(function(){
                    self.remove(id,callback,ErrorReNum);
                },ErrorReNum * self.ErrorReTime)
            }
        }

        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            if(option["multi"]){
                coll.deleteMany(query, option, result);
            }
            else {
                coll.deleteOne(query, option, result);
            }
        });
    }
    //data,[option],callback,[ErrorReNum]
    insert(data,callback,ErrorReNum) {
        var next=1,option={},callback = mongodb_callback,ErrorReNum=0;
        if(typeof arguments[next] == 'object'){
            option = arguments[next];
            next ++;
        }
        if(typeof arguments[next] == 'function'){
            callback = arguments[next];
            next ++;
        }
        if(typeof arguments[next] == 'number'){
            ErrorReNum = arguments[next];
            next ++;
        }
        if(this._MultiColl){
            return this._MultiColl.insert(data,option,callback);
        }
        var self = this;
        ErrorReNum++;
        var result = function(err,ret){
            if(!err){
                return callback(null,ret['result']);
            }
            else if( err['code'] == '11000' || ErrorReNum>=self.ErrorReCall ){
                return mongodb_ErrorLogs('insert','',data,option,err,callback);
            }
            else{
                setTimeout(function(){
                    self.add(data,option,callback,ErrorReNum);
                },ErrorReNum * self.ErrorReTime)
            }
        }
        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            if(Array.isArray(data)){
                coll.insertMany(data,option,result);
            }
            else{
                coll.insertOne(data,option,result);
            }
        });
    }

    count(query,callback){
        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            coll.count(query,callback);
        });
    }
    //id,keys,[option],callback
    find(query,option,callback) {
        if(!option['fields']){
            option['fields'] = {};
        }
        var result = mongodb_findResult.bind(this,option,callback);
        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            if(option["multi"]){
                coll.find(query, option, result);
            }
            else{
                coll.findOne(query, option, callback);
            }
        });
    }
    //update,multi and upsert 不能同时使用,findAndModify 不能使用MULTI
    update(query,update,option,callback,ErrorReNum) {
        if(typeof callback != 'function'){
            callback = this.callback;
        }
        if(this._MultiColl){
            return this._MultiColl.update(query,update,option,callback);
        }

        var self = this;
        ErrorReNum = ErrorReNum || 0;
        ErrorReNum++;

        if( option['multi'] && ( option['upsert'] || option['fields'] ) ){
            return callback('MongoError','mongodb.update use multi but set upsert or fields');
        }

        var value = function(val){
            var keys = Object.keys(option['fields']);
            var k = keys[0];
            if(keys.length > 1){
                return callback(null,val);
            }
            else if( !(k in val) ){
                return callback('MongoError',val);
            }
            else{
                return callback(null,val[k]);
            }
        }

        var result = function(err,ret){
            if(!err){
                if(option['fields']){
                    return value(ret['value']);
                }
                else{
                    return callback(null,ret['result']);
                }
            }
            else if( ErrorReNum >= self.ErrorReCall ){
                return mongodb_ErrorLogs('update',query,update,option,err,callback);
            }
            else{
                setTimeout(function(){
                    self.update(query,update,option,callback,ErrorReNum);
                },ErrorReNum * self.ErrorReTime)
            }
        }

        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            if(option['fields']){
                option['projection'] = option['fields'];
                coll.findOneAndUpdate(query,update,option, result);
            }
            else if(option['multi']){
                coll.updateMany(query, update, option, result);
            }
            else{
                coll.updateOne(query, update, option, result);
            }
        });
    }

    aggregate(pipeline, options, callback){
        this.collection(function(err,coll){
            if(err){
                return callback(err,coll);
            }
            else{
                return coll.aggregate(pipeline, options, callback);
            }
        });
    }
    
    query(keys ,fk) {
        var query = {};
        if (!keys) {
            return query;
        }
        fk = fk || '_id';
        var ObjectID = this.ObjectID || function(k){ return k;}
        if (Array.isArray(keys)) {
            var rk = [];
            keys.forEach(function(k){
                rk.push(ObjectID(k));
            });
            query[fk] = {"$in": rk};
        }
        else {
            query[fk] = ObjectID(keys);
        }
        return query;
    }

    fields(keys) {
        var fields = {};
        if (!keys) {
            return fields;
        }
        if (Array.isArray(keys)) {
            keys.forEach(function (k) {
                fields[k] = 1;
            });
        }
        else if (typeof keys == 'object') {
            fields = keys;
        }
        else {
            fields[keys] = 1;
        }
        return fields;
    }

    values(key, val) {
        var value = {};
        if (Array.isArray(key)) {
            key.forEach(function (k) {
                value[k] = val || null;
            });
        }
        else if (typeof key === 'object') {
            value = key;
        }
        else {
            value[key] = val;
        }
        return value;
    }

    ObjectID(str){
        return exports.ObjectID(str);
    }

    isMultiWrite(id) {
        if (!id || typeof id == 'object') {
            return true;
        }
        else {
            return false;
        }
    }

}

exports.ObjectID = function (str){
    if(!str){
        return mongodb.ObjectID();
    }
    else if(typeof str == 'object' || !mongodb.ObjectID.isValid(str) ){
        return str;
    }
    else{
        return mongodb.ObjectID(str);
    }
}
//mongoColl multi
function MultiColl(){
    this._MultiCache = [];
}

MultiColl.prototype.insert = function(data,option,callback){
    callback = callback || mongodb_callback;
    if(Array.isArray(data)){
        data.forEach(function(d){
            this._MultiCache.push({ insertOne: { document: d } } );
        });
    }
    else{
        this._MultiCache.push({ insertOne: { document: data } } );
    }
    return callback(null,null);
}

MultiColl.prototype.update = function(query,update,option,callback){
    callback = callback || mongodb_callback;
    var upsert = option['upsert'] ? true : false;
    if(!option['multi']){
        this._MultiCache.push({ updateOne: { filter: query , update : update ,upsert : upsert  } } );
    }
    else{
        this._MultiCache.push({ updateMany: { filter: query , update : update ,upsert : upsert  } } );
    }
    return callback(null,null);
}

MultiColl.prototype.delete = function(query,option,callback){
    callback = callback || mongodb_callback;
    if(!("single" in option)) {
        option["single"] = option["multi"] ? false : true;
    }
    if(option['single']){
        this._MultiCache.push({ deleteOne: { filter: query } } );
    }
    else{
        this._MultiCache.push({ deleteMany: { filter: query } } );
    }
    return callback(null,null);
}

function mongodb_client(key,callback) {
    if(typeof key == 'object') {
        callback(null,key);
    }
    else {
        pool.acquire(key,callback);
    }
}



function mongodb_callback(err,ret){
    return err ? false : ret;
}

//错误日志
function mongodb_ErrorLogs(method,query,update,option,error,callback){
    var code = error['code']||0;
    var name = error['name']||'MongoError';
    console.error(
        new Date().toLocaleString(),
        name,
        method,JSON.stringify(query),
        JSON.stringify(update),
        JSON.stringify(option),
        code,error['errmsg']||error['message']||''
    );
    return callback(name,code);
}

function mongodb_findResult(option,callback,err,ret){
    if(err || !ret ){
        return callback(err,ret);
    }
    var dataType = option['dataType'] || 'array';
    if(dataType === 'array'){
        getArrFromCursor(ret,callback);
    }
    else if(dataType === 'json' || dataType === 'object'){
        getObjFromCursor(ret, option, callback);
    }
    else {
        callback(err,ret);
    }
}

function getArrFromCursor(cursor,callback){
    cursor.toArray(callback);
}

function getObjFromCursor(cursor,options,callback){
    var key =  '_id',rows = {};
    cursor.each(function(err,ret){
        if(err){
            return callback(err,ret);
        }
        else if(ret===null){
            return callback(null,rows);
        }
        else{
            var id = ret[key].toString();
            rows[id] = ret;
        }
    });
}

