"use strict";
//同步/异步 执行多任务
var btask = function(tasks,worker,callback){
    if (!(this instanceof btask)) {
        return new btask(tasks,worker,callback);
    }

    var self=this, maxNum, curNum = 0,  errNum = 0, errList = [],asyn=false,interval=0;
    this.breakOnError = false;

    if(Array.isArray(tasks)){
        maxNum = tasks.length;
    }
    else if(typeof tasks =='object'){
        tasks = Object.keys(tasks);
        maxNum = tasks.length;
    }
    else{
        maxNum = parseInt(tasks);
        tasks  = null;
    }
    var result = function(err,ret){
        curNum ++;
        if(err){
            errNum ++;
            errList.push([err,ret]);
        }

        if( err && self.breakOnError){
            return callback(errNum,errList);
        }

        if(curNum >= maxNum){
            return callback(errNum,errList);
        }
        if(asyn){
            setTimeout(asyn_callback,interval);
        }
    }

    var asyn_callback = function(){
        var args = tasks ? tasks[curNum] : curNum;
        worker(args,result);
    }
    //顺序执行
    this.sequence = function(ms){
        asyn = true;
        interval = parseInt(ms||0);
        if(maxNum<1){
            return callback(errNum,errList);
        }
        else{
            asyn_callback();
        }
    }
    //并发执行
    this.concurrent = function(ms){
        asyn = false;
        interval = ms||0;
        if(maxNum<1){
            return callback(errNum,errList);
        }
        for(var i=0;i < maxNum;i++){
            var args = tasks ? tasks[i] : i;
            worker(args,result);
        }
    }
    /**
     * start 开始执行批量任务
     * @param concurrent 是否并发执行
     * @param millisecond 延时毫秒数
     */
    this.start = function(concurrent,millisecond){
        if(concurrent){
            return this.concurrent(millisecond);
        }
        else{
            return this.sequence(millisecond);
        }
    }
}

exports = module.exports = btask;