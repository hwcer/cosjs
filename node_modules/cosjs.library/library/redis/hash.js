"use strict"

const base = require('./base');
const format = require('../format');

exports = module.exports = class redis_hash extends base{

    constructor(PoolKey,PrefixChar,FormatOpts) {
        super(PoolKey,PrefixChar);
        this._FormatOpts = FormatOpts;
    }

    get(id, key, callback) {
        if (!key) {
            hgetall.call(this,id, callback);
        }
        else if (Array.isArray(key)) {
            hmget.call(this, id, key, callback);
        }
        else {
            hget.call(this,id, key, callback);
        }
    }

    set(id, key, val, callback) {
        callback = callback || this.callback;
        var hash = this.hash(id);
        var redis = this.conn();
        if (typeof(key) === 'object') {
            var rows = {};
            for (var k in key) {
                rows[k] = typeof key[k] === 'object' ? JSON.stringify(key[k]) : key[k];
            }
            redis.hmset(hash, rows, callback);
        }
        else {
            if (typeof(val) === 'object') {
                val = JSON.stringify(val);
            }
            redis.hset(hash, key, val, callback);
        }
    }

    del(id, key, callback){
        if(typeof key == 'function'){
            callback = arguments[1];
            key = null;
        }
        else{
            callback = callback || this.callback;
        }

        var hash = this.hash(id);
        var redis = this.conn();
        if (key===null) {
            redis.del(hash, callback);
        }
        else if (Array.isArray(key)) {
            key.forEach(function (k) {
                redis.hdel(hash, k);
            });
            callback(null, key.length);
        }
        else {
            redis.hdel(hash, key, callback);
        }
    }

    incr(id,key,val,callback) {
        callback = callback || this.callback;
        var hash = this.hash(id);
        var redis = this.conn();
        redis.hincrby(hash,key,val,callback);
    }

    exists(id,key,callback){
        var hash = this.hash(id);
        var redis = this.conn(true);
        if (arguments.length > 2) {
            redis.hexists(hash, key, callback);
        }
        else {
            redis.exists(hash, callback);
        }
    }

}



function hget(id, key, callback) {
    var self = this;
    var hash = this.hash(id);
    var redis = this.conn(true);
    redis.hget(hash, key, function (err, ret) {
        if (err) {
            return callback(err, ret);
        }
        else {
            if(self._FormatOpts && self._FormatOpts[key]){
                var val = format(ret,self._FormatOpts[key]['type'] )
            }
            else{
                var val = ret;
            }
            return callback(null, val );
        }
    });
}

function hmget(id, keys, callback) {
    var self = this;
    var hash = this.hash(id);
    var redis = this.conn(true);
    redis.hmget(hash, keys, function (err, ret) {
        if (err) {
            return callback(err, ret);
        }
        var data = {};
        for (let i in keys) {
            let k = keys[i];
            data[k] = ret[i];
        }
        if(self._FormatOpts){
            format(data,self._FormatOpts);
        }
        return callback(false, data);
    });
}

function hgetall(id, callback) {
    var self = this;
    var hash = this.hash(id);
    var redis = this.conn(true);
    redis.hgetall(hash, function (err, ret) {
        if (err) {
            return callback(err, ret);
        }
        if(self._FormatOpts){
            format(ret,self._FormatOpts,true);
        }
        return callback(false, ret);
    })
}